from math import sqrt,inf
import random
import time
#####################GREEDY
def closest_aviable(point,path,list): #finds the closest point that hasn't been visited yet
    min = 0
    while min in path or min == point:
        min += 1
    for i in range(len(list)):
        if i not in path and i != point and list[point][min] >= list[point][i]:
            min = i
    return min

def recursive_path(point, path, distance, matrix): #our greedy TSP solution
    path.append(point) #adds current point to the path
    new_point = closest_aviable(point,path,matrix)
    if len(path) == len(matrix): # if all vertex has been visited
        path.append(0) #we add out startpoint
        for i in range(len(path)):
            path[i] += 1
        return path, distance+matrix[0][point]
    else:
        distance += matrix[point][new_point]
        return recursive_path(new_point, path, distance, matrix)

###GREEDY


def distance(x1,x2,y1,y2):
    return sqrt((x1-x2)**2 + (y1-y2)**2)

def randompick(distance,trail,tabu): #based on probability
    a,b = 1,10 #a=trail factor,b=distance factor
    score = [] #numerical value of each city
    for i in (range(len(distance))):
        if i in tabu:
            score.append(0)
        else:
            x = (trail[i]**a)*(distance[i]**(-b))
            score.append(x)

    probability = [score[i] / sum(score) for i in range(len(distance))]
    for i in range(1,len(distance)):
        probability[i]+=probability[i-1]
    probability = [round(x,7) for x in probability]
    pick_index = random.uniform(0,1)
    pick = 0 #the city we chooose
    while pick_index >  probability[pick]:
        pick+=1
    return pick

class Graph:
    def __init__(self,n,points): #constructor
        self.matrix = [[0 for i in range(n)] for j in range(n)] #adjacency matrix
        for i in range(len(points)): #we fill our matrix with the distances
            #[p, x, y,] = points[i].split(' ')
            kkk = points[i].split(' ')
            p = kkk[0]
            x = kkk[1]
            y = kkk[2]
            p, x, y = int(p)-1, int(x), int(y)
            for j in range(i, len(points)):
                #[p1, x1, y1] = points[j].split(' ')
                kkk = points[j].split(' ')
                p1 = kkk[0]
                x1 = kkk[1]
                y1 = kkk[2]
                p1, x1, y1 = int(p1)-1, int(x1), int(y1)
                self.matrix[p][p1] = self.matrix[p1][p] = distance(x,x1,y,y1)

    def antcolony(self):
        start = time.time()
        NC = 100
        MIN_LEN = inf
        MIN_PATH = []
        counter = 0 #to break out of the loop if no progress is noticed
        N = len(self.matrix)
        ant_count = min(15,N) #probably not the best solution,for testing
        vapor_factor = 0.7
        trail = [[1 for i in range(N)] for j in range(N)]
        delta_trail = [[0 for i in range(N)] for j in range(N)]
        ants = [i for i in range(N)]
        for trials in range(NC):
            index = 0
            flag = False
            LEN = []
            visited_cities = [[] for i in range(ant_count)]

            for k in range(ant_count):
                visited_cities[k].append(ants[k])
            for times in range(N-1):
                for ant in range(ant_count):
                    i = visited_cities[ant][-1]
                    y = randompick(self.matrix[i],trail[ant],visited_cities[ant])
                    visited_cities[ant].append(y)
            for ant in range(ant_count):
                visited_cities[ant].append(visited_cities[ant][0])
                LEN.append(sum( [ self.matrix[ visited_cities[ant][i] ][visited_cities[ant][i+1]] for i in range(len(self.matrix))]))
                if LEN[ant] <= LEN[index]:
                    index = ant

                for i in range(N):
                    delta_trail[visited_cities[ant][i]][visited_cities[ant][i+1]]+=(1/LEN[ant])



            for i in range(ant_count):
                if LEN[i] < MIN_LEN:
                    MIN_LEN = LEN[i]
                    MIN_PATH = visited_cities[i]
                    flag = True
                    counter = 0



            for i in range(N) :
                for j in range(N):
                    trail[i][j] = vapor_factor*trail[i][j] + delta_trail[i][j]
            if not(flag):
                counter+=1
            if counter > NC*0.7:
                break
            if time.time() - start > 600:
                break

            delta_trail = [[0 for i in range(N)] for j in range(N)]

            print(MIN_LEN)
        return MIN_LEN,MIN_PATH

    def greedy(self):
        return recursive_path(0, [], 0, self.matrix)




def main():
    contents = open("berlin52.txt", "r").readlines() #load data
    n = int(contents[0]) # number of vertex
    contents = contents[1:] #coordinates of vertex (starts at one)
    graph = Graph(n, contents)
    print(graph.antcolony())
    print(graph.greedy())
main()
